#!/usr/bin/env python3
"""
Debug script to trace why pixel (0,0) has zero weights.
Pure Python - no dependencies.
"""

from math import exp, sqrt, pi

def gaussian_weights_pure(tile_w, tile_h):
    '''Gaussian weight generation from tiled_diffusion.py - pure Python'''
    f = lambda x, midpoint, var=0.01: exp(-(x-midpoint)*(x-midpoint) / (tile_w*tile_w) / (2*var)) / sqrt(2*pi*var)
    x_probs = [f(x, (tile_w - 1) / 2) for x in range(tile_w)]
    y_probs = [f(y,  tile_h      / 2) for y in range(tile_h)]

    # Simulate outer product
    weights = [[y_probs[i] * x_probs[j] for j in range(tile_w)] for i in range(tile_h)]
    return weights

print("="*80)
print("DEBUG: Why is pixel (0,0) uncovered?")
print("="*80)

# Simulate the scenario
image_w_latent = 512
image_h_latent = 232
overlap = 6

# Simulate a tile at core (0, 0, 64, 64) - this should cover pixel (0,0)
# After overlap: tile at (-6, -6, 76, 76)
core_x, core_y, core_w, core_h = 0, 0, 64, 64
x = core_x - overlap  # -6
y = core_y - overlap  # -6
w = core_w + 2 * overlap  # 76
h = core_h + 2 * overlap  # 76

print(f"\nTile 1: Core at ({core_x}, {core_y}, {core_w}, {core_h})")
print(f"        With overlap: ({x}, {y}, {w}, {h})")

# Get Gaussian weights
tile_weights = gaussian_weights_pure(w, h)
print(f"        Gaussian weights shape: {h}x{w}")

# Key weight values
center = 38
offset = 6
print(f"        Weight at [{center}, {center}] (center): {tile_weights[center][center]:.6f}")
print(f"        Weight at [{offset}, {offset}] (maps to image 0,0): {tile_weights[offset][offset]:.6f}")

# Calculate intersection with image
x_start = max(0, x)
y_start = max(0, y)
x_end = min(image_w_latent, x + w)
y_end = min(image_h_latent, y + h)

print(f"\nIntersection with image:")
print(f"        x: [{x_start}, {x_end}) - covers {x_end - x_start} pixels")
print(f"        y: [{y_start}, {y_end}) - covers {y_end - y_start} pixels")

# Calculate tile offsets
tile_x_offset = x_start - x
tile_y_offset = y_start - y
tile_x_end_offset = tile_x_offset + (x_end - x_start)
tile_y_end_offset = tile_y_offset + (y_end - y_start)

print(f"\nTile weights slice:")
print(f"        y: [{tile_y_offset}, {tile_y_end_offset}) - {tile_y_end_offset - tile_y_offset} elements")
print(f"        x: [{tile_x_offset}, {tile_x_end_offset}) - {tile_x_end_offset - tile_x_offset} elements")

# Perform accumulation
if x_end > x_start and y_end > y_start:
    print(f"\n✓ Condition met: accumulation WILL happen")

    # The weight that would be added to pixel (0,0)
    weight_for_00 = tile_weights[tile_y_offset][tile_x_offset]
    print(f"\nWeight contributed to pixel (0,0):")
    print(f"        tile_weights[{tile_y_offset}][{tile_x_offset}] = {weight_for_00:.6f}")

    if weight_for_00 > 1e-6:
        print(f"\n✓ SUCCESS: Pixel (0,0) SHOULD get weight {weight_for_00:.6f}")
        print(f"   This means the basic logic is CORRECT.")
        print(f"   The bug must be elsewhere!")
    else:
        print(f"\n✗ FAILURE: Weight is too small ({weight_for_00})")
        print(f"   This could be a Gaussian weight calculation issue")
else:
    print(f"\n✗ Condition NOT met - no accumulation would happen!")

print(f"\n" + "="*80)
print("HYPOTHESIS: Check gaussian_weights() asymmetry")
print("="*80)

# Let's check if the asymmetry in gaussian_weights() could cause issues
tile_size = 76

f_test = lambda x, midpoint, var=0.01: exp(-(x-midpoint)*(x-midpoint) / (tile_size*tile_size) / (2*var)) / sqrt(2*pi*var)

x_midpoint = (tile_size - 1) / 2  # 37.5
y_midpoint = tile_size / 2  # 38.0

print(f"\nFor tile size {tile_size}:")
print(f"  x_probs midpoint: {x_midpoint}")
print(f"  y_probs midpoint: {y_midpoint}")
print(f"  Difference: {y_midpoint - x_midpoint} (y midpoint is 0.5 higher)")

# Calculate the probability at index 6 (which maps to pixel 0,0)
index = 6
x_prob_6 = f_test(index, x_midpoint)
y_prob_6 = f_test(index, y_midpoint)

print(f"\n  x_probs[{index}] = {x_prob_6:.6f}")
print(f"  y_probs[{index}] = {y_prob_6:.6f}")
print(f"  Product = {x_prob_6 * y_prob_6:.6f}")

print(f"\n  This IS the weight at tile_weights[{index}][{index}]")
print(f"  And it MATCHES what we calculated above: {tile_weights[offset][offset]:.6f}")

print(f"\n" + "="*80)
print("CONCLUSION SO FAR")
print("="*80)
print("""
The basic weight accumulation logic appears CORRECT:
  1. Tile at core (0,0,64,64) expands to (-6,-6,76,76) with overlap=6
  2. Intersection with image gives region [0,70) × [0,70)
  3. Tile offsets are correctly calculated as [6,76) × [6,76)
  4. Weight tile_weights[6][6] is added to image pixel (0,0)
  5. This weight is NON-ZERO (around 0.5-0.9 typically)

If pixel (0,0) is still showing zero weight in the actual code,
the bug must be in one of these areas:

A. NO TILE covering (0,0) is being generated by the quadtree
B. Tiles covering (0,0) are being FILTERED out incorrectly
C. The loop processing tiles is SKIPPING some tiles
D. There's a dimension swap bug (y/x confusion)
E. self.weights is being RESET after accumulation
F. Broadcasting issue when adding 2D to 4D tensor

Let's check each...
""")

print("\n" + "="*80)
print("HYPOTHESIS A: Check if tile at (0,0) should exist")
print("="*80)

# For a 512×232 latent image, the quadtree would create tiles
# The smallest tile size in the user's case seems to be around 64-80 latent pixels
# So there SHOULD be tiles covering (0,0)

print("For 512×232 latent image:")
print("  - Tiles should start from (0,0)")
print("  - First tile likely at core (0,0,64,64) or similar")
print("  - After overlap=6, becomes (-6,-6,76,76)")
print("  - This SHOULD cover pixel (0,0)")
print("\n✓ Tiles covering (0,0) SHOULD exist")

print("\n" + "="*80)
print("HYPOTHESIS B: Check filtering logic")
print("="*80)

# Simulate the filtering logic from lines 392-438
core_start_x = 0
core_start_y = 0
core_end_x = 64
core_end_y = 64

tile_start_x = core_start_x - overlap  # -6
tile_start_y = core_start_y - overlap  # -6
tile_end_x = core_end_x + overlap  # 70
tile_end_y = core_end_y + overlap  # 70

image_w = 512
image_h = 232

core_outside_x = core_start_x >= image_w or core_end_x <= 0
core_outside_y = core_start_y >= image_h or core_end_y <= 0
tile_no_overlap_x = tile_start_x >= image_w or tile_end_x <= 0
tile_no_overlap_y = tile_start_y >= image_h or tile_end_y <= 0

should_filter = core_outside_x or core_outside_y or tile_no_overlap_x or tile_no_overlap_y

print(f"For tile with core (0,0,64,64), overlap=6:")
print(f"  core_outside_x: {core_start_x} >= {image_w} or {core_end_x} <= 0 = {core_outside_x}")
print(f"  core_outside_y: {core_start_y} >= {image_h} or {core_end_y} <= 0 = {core_outside_y}")
print(f"  tile_no_overlap_x: {tile_start_x} >= {image_w} or {tile_end_x} <= 0 = {tile_no_overlap_x}")
print(f"  tile_no_overlap_y: {tile_start_y} >= {image_h} or {tile_end_y} <= 0 = {tile_no_overlap_y}")
print(f"  should_filter: {should_filter}")

if should_filter:
    print("\n✗ TILE WOULD BE FILTERED! This is the bug!")
else:
    print("\n✓ Tile should NOT be filtered - filtering logic is correct")

print("\n" + "="*80)
